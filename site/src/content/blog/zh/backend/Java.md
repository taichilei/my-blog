---
title: "Java"
description: "Java 相关笔记"
pubDate: "2026-01-18"
---

# Java

## 访问控制

| private   | 私有的   |
| --------- | -------- |
| protected | 受保护的 |
| public    | 公共的   |
| default   | 默认     |

- 

final

- 简单介绍一下lamda表达式

---

Stream流

利用对顺序没有要求的场景，利用了CPU多核的特性

中间操作

| filter   | 对集合数据进行过滤操作 |
| -------- | ---------------------- |
| map      | 转换操作               |
| limit    | 获取前几条             |
| skip     | 跳过几条               |
| distinct | 去重                   |
| sorted   | 排序                   |

终结操作

| collect  | 放入集合 |
| -------- | -------- |
| forearch | 遍历     |
| count    | 统计     |
| toArray  | 放入数组 |

Stream特性

1. ﻿﻿﻿延迟执行，Stream的中间方法只有在终结操作的时候才会执行。比如调用collect的时候，才会去做filter等中间方法的操作。
2. ﻿﻿﻿Stream不会改变数据源，每次操作都会生成一个新的流，比如我过滤设计模式，原来的products是不影响的。
3. ﻿﻿﻿不存储数据，Stream不是一个数据存储结构，是通过管道拿取数据源进行操作，生成新的流。
4. ﻿﻿﻿可并行，我们可以通过parallelStream（）去并行处理，充分利用多核的优势。

---

## 注解


```java
@Entity
```



## 业务场景题

- 面试官：你遇到过HashMap扩容问题吗？线上服务突然变慢，排查发现大量扩容操作，如何快速定位并优化？
- 这题我遇到过。HashMap扩容如果初始容量小或元素多，
  - 负载因子超限，会导致扩容操作耗时，引发服务变慢。快速定位：先查GC日志和CPU使用率，找高负载时段；用jstack或
  - VisualVM分析线程堆栈，定位到HashMap put操作触发扩容的代码。
  - 优化方案：预估好初始容量和负载因子，比如容量设为预计元素数除以0.75；避免默认值，减少扩容频率；如果高并发，改用ConcurrentHashMap。这里有个易踩坑的点，扩容时
  - Hash Map不是线程安全的，容易导致数据丢失或死循环，记得在并发场景下用同步集合。

---

- Stream流和for的区别是什么？
  - for循环是命令式思维
  - Stream流是声明式思维
